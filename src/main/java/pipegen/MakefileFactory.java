/*
    Program:  MakefileFactory.java
    Author:   Michael Stokman
              Albert Einstein College of Medicine

    Purpose:  This factory class composes the makefile content and writes it to 
              disk in preparation for analysis with the class MakefileAnalysis.

 */

package pipegen;

import java.io.*;
import java.util.*;
import java.text.*;

import pipegen.exceptions.*;
import pipegen.instances.*;


public class MakefileFactory {

    private File makefile;
    private File makefileDir;
    private DataTableFile table;
    private PipelineInstance pipeline;

    private String targetList;
    private String intermediateList;

    private String text;

    public MakefileFactory(File makefile, DataTableFile table, PipelineInstance pipeline) {

        this.makefile = makefile;
        this.makefileDir = makefile.getParentFile();
        this.table = table;
        this.pipeline = pipeline;
    }

    /**
     * Composes the contents of this makefile and writes it to disk
     */
    public void composeAndWrite() throws InvalidMakefileException {
        composeText();
        writeFile();
    }

    /**
     * Composes the contents of this makefile
     */
    private void composeText() throws InvalidMakefileException  {

        StringBuilder sb = new StringBuilder(32768);
        sb.append(composeHeaderComments());   // Header comments
        sb.append(composeInitialSection());   // Initial section
        sb.append(composeSetupSection());     // Setup targets section
        sb.append(composeMainSection());      // Main targets section
        sb.append(composeCleanupSection());   // Cleanup targets section
        sb.append(composePrintingSection());  // Printing targets section
        text = sb.toString();
    }

    /**
     * Writes the contents of this makefile to disk
     */
    public void writeFile() throws InvalidMakefileException {

        PrintWriter writer = null;
        BufferedWriter buffer = null;
        try {

            // Create enclosing directory if needed
            if(! makefileDir.isDirectory()) {
                makefileDir.mkdir();
            }

            // Create makefile if needed
            if(! makefile.exists()) {
                makefile.createNewFile();
            }

            // Write contents to makefile
            writer = new PrintWriter(makefile, "UTF-8");
            buffer = new BufferedWriter(writer);
            buffer.write(text);
            buffer.close();

        } catch (IOException e) {
            e.printStackTrace();
            throw new InvalidMakefileException(e);
        } finally {
            try {
                if (writer != null) {
                    writer.close();
                }
                if (buffer != null) {
                    buffer.close();
                }
            } catch (IOException e) {
                e.printStackTrace();
                throw new InvalidMakefileException(e);
            }
        }
    }

    /**
     * Composes header comment for the makefile. Includes the time the makefile 
     * was composed.
     */
    private String composeHeaderComments() {

        Date date = new Date();
        SimpleDateFormat dayForm = new SimpleDateFormat ("EEEE, MMMM d yyyy.");
        SimpleDateFormat timeForm = new SimpleDateFormat ("hh:mm a");

        StringBuilder sb = new StringBuilder();
        sb.append("#\n");
        sb.append("#    This makefile was generated by pipe-gen\n");
        sb.append("#\n");
        sb.append("#    " + dayForm.format(date) + "\n");
        sb.append("#    " + timeForm.format(date) + "\n");
        sb.append("#\n");
        sb.append("\n");
        sb.append("\n");

        return sb.toString();
    }

    /**
     * Composes the initialization section of the makefile
     */
    private String composeInitialSection() {

        String[] idList = table.getColumnByHeader("id");
        String[] makeVariables = table.getMakeVariables();
        ArrayList<SinkElement> sinks = pipeline.getSinks();

        String idListString = "";
        String setupListString = "";
        for (int i=0; i < idList.length; i++) {
            idListString += " id" + idList[i];
            setupListString += " setup" + idList[i];
        }

        StringBuilder sb = new StringBuilder();

        // Define processing directory
        sb.append("# Processing directory for intermediate files\n");
        sb.append("PROCESSING = ./PROCESSING_DIRECTORY/\n");
        sb.append("\n");

        // Define error log directory
        sb.append("# Error log directory\n");
        sb.append("ERRORS = ./ERROR_LOGS/\n");
        sb.append("\n");        

        // Define list of ID's
        sb.append("# List processing subroutines for each ID\n");
        sb.append("IDLIST =" + idListString + "\n");
        sb.append("\n");

        // Define list of setup subroutines
        sb.append("# List setup subroutines for each ID\n");
        sb.append("SETUPLIST =" + setupListString + "\n");
        sb.append("\n");

        // Target all ID's  for analysis
        sb.append("# Target all IDs for processing\n");
        sb.append("all: $(IDLIST)\n");
        sb.append(".PHONY: all\n");
        sb.append(".PHONY: $(IDLIST)\n");
        sb.append("\n");

        for (int i=0; i < idList.length; i++) {
            sb.append("id" + idList[i] + ": ");
            for (int j=0; j < sinks.size(); j++) {
                sb.append(sinks.get(j).getPhoneyname(idList[i]) + " ");
            }
            sb.append("\n");
        }
        sb.append("\n");

        // Defines makefile variables specific to each ID
        sb.append("# ID specific makefile variables\n");
        for (int i=0; i < idList.length; i++) {
            for (String variable : makeVariables) {
                sb.append("id" + idList[i] + "_" + variable + " = " + table.getDataByHeaderAndRowid("$(" + variable + ")", idList[i]) + "\n");
            }
            sb.append("\n");
        }

        return sb.toString();
    }

    /**
     * Composes the section of the makefile that handles setting up the 
     * directory structure prior to running the analysis.
     */
    private String composeSetupSection() {

        String[] idList = table.getColumnByHeader("id");

        StringBuilder sb = new StringBuilder();

        // Append line comment
        sb.append(lineComment("SETUP TARGETS"));
        sb.append("\n");

        // Implement setup subroutines
        sb.append("# Create processing subdirectory for each ID\n");
        sb.append(".PHONY: setupall\n");
        sb.append("setupall: $(SETUPLIST)\n");
        sb.append("\n");

        sb.append("# Clear error logs and create error log directory\n");
        sb.append(".PHONY: seterror\n");
        sb.append("setuperror: cleanerror\n");
        sb.append("\tmkdir -p $(ERRORS)\n");
        sb.append("\n");

        sb.append(".PHONY: $(SETUPLIST)\n");
        sb.append("\n");

        for (int i=0; i < idList.length; i++) {
            sb.append("setup" + idList[i] + ": setuperror\n");
            sb.append("\tmkdir -p $(PROCESSING)/" + idList[i] + "\n");
            sb.append("\n");
        }

        return sb.toString();
    }

    /**
     * Composes the main section of the makefile that handles producing the  
     * running the analysis.
     */
    private String composeMainSection() throws InvalidMakefileException {

        targetList = "";
        intermediateList = "";
        String[] makeVariables = table.getMakeVariables();
        ArrayList<SinkElement> sinks = pipeline.getSinks();
        String[] idList = table.getColumnByHeader("id");

        StringBuilder sb = new StringBuilder();

        // Append line comment
        sb.append(lineComment("MAKE ALL"));
        sb.append("\n");

        // Add the dependency tree for each file in SINKS
        BlockElementVisitor blockVisitor;
        for (SinkElement sink : sinks) {
            for (String id : idList) {
                blockVisitor = new BlockElementVisitor(table);
                int sinkID = sink.getID();
                String target = sink.asTarget(id);

                blockVisitor.visit(sink, id);
                String newTarget = sink.getFilename(id, table);
                String newIntermediates = blockVisitor.getIntermediateList();

                for (String variable : makeVariables) {
                    newTarget = newTarget.replace("$(" + variable + ")", "$(id" + id + "_" + variable + ")");
                    newIntermediates = newIntermediates.replace("$(" + variable + ")", "$(id" + id + "_" + variable + ")");
                }

                targetList += " " + newTarget;
                intermediateList += " " + newIntermediates;
                sb.append(blockVisitor.getText());
            }
        }

        return sb.toString();
    }

    /**
     * Composes the section of the makefile that handles cleaning files from 
     * previous analyses.
     */
    private String composeCleanupSection() {

        StringBuilder sb = new StringBuilder();

        // Append line comment
        sb.append(lineComment("CLEAN UP"));
        sb.append("\n");

        // Declare cleaning targets
        sb.append(".PHONY: cleanall cleanerror cleanprocess\n");
        sb.append("\n");

        sb.append("cleanall: cleanerror cleanprocess\n");
        sb.append("\n");

        sb.append("cleanerror:\n");
        sb.append("\trm -rf $(ERRORS)* \n");
        sb.append("\n");

        sb.append("cleanprocess:\n");
        sb.append("\trm -f $(targetList) $(intermediateList) \n");
        sb.append("\n");

        return sb.toString();
    }

    /**
     * Composes the section of the makefile that handles targets for printing 
     * the progress of analysis 'target_ratio' and 'intermediate_ratio'.
     */
    private String composePrintingSection() {

        StringBuilder sb = new StringBuilder();

        // Append line comment
        sb.append(lineComment("PRINTING TARGETS"));
        sb.append("\n");

        // Declare printing targets
        sb.append(".PHONY: target_ratio total_ratio\n");
        sb.append("\n");
        sb.append("# List target files (output files attached to a sink)\n");
        sb.append("targetList =" + targetList + "\n");
        sb.append("\n");
        sb.append("# List intermediate files\n");
        sb.append("intermediateList =" + intermediateList + "\n");
        sb.append("\n");
        sb.append("# Print ratio (existing target files / total target files)\n");
        sb.append("target_ratio:\n");
        sb.append("\t$(eval numeratorTarget = $(shell ls $(targetList) | uniq | wc -l))\n");
        sb.append("\t$(eval denominatorTarget = $(shell echo $(targetList) | xargs -n1 | sort -u | wc -l))\n");
        sb.append("\t@echo $(numeratorTarget) / $(denominatorTarget)\n");
        sb.append("\n");
        sb.append("# Print ratio (existing intermediate files / total intermediate files)\n");
        sb.append("intermediate_ratio:\n");
        sb.append("\t$(eval numeratorIntermediate = $(shell ls $(intermediateList) | uniq | wc -l))\n");
        sb.append("\t$(eval denominatorIntermediate = $(shell echo $(intermediateList) | xargs -n1 | sort -u | wc -l))\n");
        sb.append("\t@echo $(numeratorIntermediate) / $(denominatorIntermediate)\n");

        return sb.toString();
    }

    /**
     * Generates a line comment of the form "#------    comment    -------\n"
     * Inserts dashes as needed to achieve a standardized width
     */
    private String lineComment(String comment) {

        int length = 88;
        int commentWithSpace = comment.length() + 8;
        int firstHalf = (length - commentWithSpace) / 2;
        StringBuilder sb = new StringBuilder(length);

        // Append the first half of the line comment "#-------"
        sb.append("#");
        for (int i=1; i < firstHalf; i++) {
            sb.append("-");
        }

        // Append the comment with some whitespace
        sb.append("    " + comment + "    ");

        // Append the second half of the line comment "-------\n"
        while (sb.length() < length) {
            sb.append("-");
        }
        sb.append("\n");

        return sb.toString();

    }

    /**
     * Returns the text contents of the makefile generated by this factory
     */
    public String getMakefileText() {
        return text;
    }
}
