/*
    Program:  BlockElementVisitor.java
    Author:   Michael Stockman
              Albert Einstein College of Medicine

    Purpose:  This class implements the VISITOR PATTERN to traverse a graph of 
              connected BlockElements.

              The visitors accrue the appropriate makefile text for each node
              as they visit them. The visitor starts from the makefile outputs
              SourceElements and then traverse 'upstream' moving to each node's
              parents.

              The make code generated by using BlockElementVisitor is then 
              turned into a file by the MakefileFactory class. And finished 
              makefiles can be run by the MakefileAnalysis class. 

 */

package pipegen;

import java.io.*;

import pipegen.exceptions.*;
import pipegen.instances.*;


public class BlockElementVisitor {

    private DataTableFile table;
    private String intermediateList;
    private StringBuilder sb;
    private boolean validBranch;
    private String[] makeVariables;

    public BlockElementVisitor(DataTableFile table) throws InvalidMakefileException {
        this.table = table;
        intermediateList = "";
        sb = new StringBuilder();
        validBranch = true;
        this.makeVariables = table.getMakeVariables();
    }

    /**
     * Visit a BlockElement and generate relevant makefile text. This is a 
     * slightly awkward way to mimic polymorphism, but it will work for now.
     */
    public void visit(BlockElement block, String id) throws InvalidMakefileException {
        if (block instanceof ModuleElement) {
            visit((ModuleElement)block, id);
        } else if (block instanceof SourceElement) {
            visit((SourceElement)block, id);
        } else if (block instanceof SinkElement) {
            visit((SinkElement)block, id);
        }
    }

    /**
     * Visit a SinkElement and generate relevant makefile text
     */
    public void visit(SinkElement sink, String id) throws InvalidMakefileException {

        sb.append("# id " + id + " at sink " + sink.getBlockName() + "\n");

        // Ignore this SinkElement if it is not connected to other elements
        BlockElement parent = sink.getParent(0);
        if (parent == null) {
            validBranch = false;
            sb = new StringBuilder();
            return;
        }

        // Setup variables
        String inFile = sink.getInput().getFilename(id, table);
        String outFile = sink.getFilename(id, table);
        String phoneyFile = sink.getPhoneyname(id);
        if (inFile == null || outFile == null || phoneyFile == null) {
            throw new InvalidMakefileException();
        }

        // Build rule for the visited source
        String rule = "";
        rule += ".PHONEY: " + phoneyFile + "\n";
        rule += phoneyFile + ": " + inFile + "\n";
        rule += "\tcp " + inFile + " " + outFile + "\n";
        rule += "\n";

        // Replace all user provided makefile variables with an ID specific version 
        for (String variable : makeVariables) {
            rule = rule.replace("$(" + variable + ")", "$(id" + id + "_" + variable + ")");
        }

        // Append the new rule to makefile text
        sb.append(rule);

        // Visit the parents of this source
        if (parent != null && sink.isFirstOutputOf(parent)) {
            visit(parent, id);
        }
    }

    /**
     * Visit a ModuleElement and generate relevant makefile text
     */
    public void visit(ModuleElement module, String id) throws InvalidMakefileException {

        sb.append("# id " + id + " at module " + module.getName() + "\n");
        BlockElement[] parents = module.getParents();

        for (int i=0; i < module.getOutputsLength(); i++) {
            intermediateList += " " + module.getFilename(id, i);
        }

        // Setup variables
        String targets;
        String prereqs;
        String recipe;
        String errorCatch;

        // Build a makefile rule for the current ModuleElement and id. Modules 
        // with more than one output need special consideration.
        String rule = "";
        if (module.getOutputsLength() == 1) {

            // Setup variables
            targets = module.getFilename(id, 0);
            prereqs = "";
            for (BlockElement parent : parents) {
                if (parent != null) {
                    prereqs += " " + parent.getFilename(id, table);
                }
            }
            recipe = module.getRecipe(id, table);
            errorCatch = module.getErrorCatch(id);

            // Build rule for the visited module
            rule += targets + ":" + prereqs + "\n";
            rule += "\t" + recipe + " " + errorCatch + "\n";
            rule += "\n";

        } else {

            // Setup variables
            targets = "";
            for (int i=0; i < module.getOutputsLength(); i++) {
                targets += " " + module.getFilenamePattern(id, i);
            }
            prereqs = "";
            for (int i=0; i < module.getInputsLength(); i++) {
                prereqs += " " + module.getInputPattern(id, i);
            }
            recipe = module.getRecipe(id, table);
            errorCatch = module.getErrorCatch(id);

            // Build main rule for the visited module
            rule += targets + ":" + prereqs + "\n";
            rule += "\t" + recipe + " " + errorCatch + "\n";
            rule += "\n";

            // Build an additional symbolic link rule for each prerequisite.
            // Links allow names to match for the use of a makefile pattern rule
            // needed for correct handling of rules with more than one target. 
            for (int i=0; i < parents.length; i++) {

                targets = module.getFilenameInput(id, i);
                prereqs = parents[i].getFilename(id, table);
                String linked = prereqs.replaceFirst("\\$\\(PROCESSING\\)", "\\.\\./\\.\\./\\$\\(PROCESSING\\)");

                rule += targets + ": " + prereqs + "\n";
                rule += "\tln -sf " + linked + " " + targets + "\n";

                rule += "\n";
                intermediateList += " " + targets;
            }
        }

        // Replace all user provided makefile variables with an ID specific version 
        for (String variable : makeVariables) {
            rule = rule.replace("$(" + variable + ")", "$(id" + id + "_" + variable + ")");
        }

        // Append the new rule(s) to makefile text
        sb.append(rule);

        // Visit the parents of this module
        for (BlockElement parent : parents) {
            if (parent != null && module.isFirstOutputOf(parent)) {
                visit(parent, id);
            }
        }
    }

    /**
     * Visit a SourceElement and generate relevant makefile text
     */
    public void visit(SourceElement source, String id) throws InvalidMakefileException {

        // Generate rules for sources with argument-type data
        if (source.isArg()) {

            // Setup variables
            String name = source.getName();
            String target = source.getFilename(id, table);
            String contents = "\"" + source.getContents(id, table) + "\"";

            // Build rule for the visited source
            String rule = "";
            rule += "# id " + id + " at source " + name + "\n";
            rule += target + ":\n";
            rule += "\t[ ! -f " + target + " ] && echo " + contents + " > " + target + "; if [ -f " + target + " ] && [ `cat " + target + "` != " + contents + " ]; then echo " + contents + " > " + target + "; fi\n"; 
            rule += "\n";

            intermediateList += " " + target;

            // Append the new rule to makefile text
            sb.append(rule);
        }
    }

    /**
     * Returns the portion of makefile text generated during this visitor's 
     * traversal of the workflow.
     */
    public String getText() {
        return sb.toString();
    }

    /**
     * Returns a space delimited list of intermediate files created by the
     * makefile based on those encountered so far by this visitor.
     */
    public String getIntermediateList() {
        return intermediateList;
    }
}
